<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<html>
<head>
<link rel="stylesheet" href="GDoc.css" type="text/css">
<title>pscf_pd_f</title>
</head>
<body bgcolor="#FFFFFF">
<br />
<p>
[<a href="toc.html#top">table of contents</a>]
[<a href="master_index.html#top">master index</a>]
[<a href="comment_index.html#top">comments</a>]
[<a href="module_index.html#top">modules</a>]
[<a href="program_index.html#top">programs</a>]
[<a href="variable_index.html#top">variables</a>]
[<a href="type_index.html#top">types</a>]
[<a href="procedure_index.html#top">procedures</a>]
</p>
<h3 align="center">TABLE OF CONTENTS</h3>
<ul><li>program <a href="#pscf_pd">pscf_pd</a></li>
<h2 id="pscf_pd" ><a href="pscf_pd_f_.html#pscf_pd" target="source">pscf_pd</a></h2>
<p><strong>PROGRAM</strong></p>  <pre>
    <strong>pscf_pd</strong>
</pre>
<p><strong>PURPOSE</strong></p>  <pre>
    Main program for polymer self-consistent field theory (PSCF) for 
    spatially periodic (PD) microstructures. The program can treat 
    incompressible mixtures of any number of linear multiblock 
    copolymers, linear homopolymers, and small molecule solvents.
 
    This program contains a main loop that reads an <a href="io/io_mod_f.html#input">input</a> script from
    standard input. The loop, and the operation of the program, ends
    when a line containing the word FINISH is encountered. The manual 
    contains detailed description of the format of this script, but a
    brief description is also given here:
    
    Input Script Format:
    The first line of the <a href="io/io_mod_f.html#input">input</a> script must be of the "format i j", in 
    which i and j are major and minor version numbers for the <a href="io/io_mod_f.html#input">input</a> 
    script file format (e.g., "format 1 0" for v1.0). The rest of the 
    <a href="io/io_mod_f.html#input">input</a> script consists of a series of blocks of <a href="io/io_mod_f.html#input">input</a> data. Each
    block begins with a blank line followed by a line containing a 
    capitalized operation flag (op_flag) string, such as 'CHEMISTRY', 
    'UNIT_CELL', 'DISCRETIZATION', 'ITERATION', etc.  The remainder 
    of each block (if any) is a series of variable values. Each 
    variable is preceded by a comment line containing the name of 
    the variable, as used in the program. One and two-dimensional
    array variables may be <a href="io/io_mod_f.html#input">input</a> in any of several formats (e.g., all
    values on a single line, or on multiple lines). See the manual
    for the format of such variables.  Some operation flags, such 
    as 'ITERATE' and 'SWEEP', trigger an action, beyond reading in 
    variables. Reading of the script, and the program, ends when the 
    'FINISH' flag is encountered.
 
    Within each block, <a href="io/io_mod_f.html#input">input</a> variables are read using the <a href="io/io_mod_f.html#input">input</a>()
    interface of the <a href="io/io_mod_f.html#io_mod">io_mod</a> module. This is an overloaded interface
    that can be used to read in a scalar or array of integer, real,
    character, or boolean data. The main program uses the comment
    style 'A' (for 'Above') of <a href="io/io_mod_f.html#io_mod">io_mod</a>, in which the value of each
    <a href="io/io_mod_f.html#input">input</a> variable is preceded by a line containing the name of
    the variable. Within each block, variables must appear in a 
    predetetermined format.  The required format is documented in
    the manual, and in example scripts provided with the program.
    All data is read using the fortran read(5,*) format, so that
    the data format and use of white space is flexible, as <a href="const_mod_f.html#long">long</a> 
    as each data value is of the expected data type. 
      
</pre>
<p><strong>SOURCE</strong></p>  <pre>
program <strong>pscf_pd</strong>
   use <a href="const_mod_f.html#const_mod">const_mod</a>
   use <a href="io/string_mod_f.html#string_mod">string_mod</a>
   use <a href="io/io_mod_f.html#io_mod">io_mod</a>
   use <a href="io/version_mod_f.html#version_mod">version_mod</a>
   use <a href="io/field_io_mod_f.html#field_io_mod">field_io_mod</a>
   use <a href="scf/chemistry_mod_f.html#chemistry_mod">chemistry_mod</a>, only : <a href="scf/chemistry_mod_f.html#input_chemistry">input_chemistry</a>, <a href="scf/chemistry_mod_f.html#rescale_vref">rescale_vref</a>, &
                             <a href="scf/chemistry_mod_f.html#input_monomers">input_monomers</a>, <a href="scf/chemistry_mod_f.html#input_chains">input_chains</a>, <a href="scf/chemistry_mod_f.html#input_solvents">input_solvents</a>,&
                             <a href="scf/chemistry_mod_f.html#input_composition">input_composition</a>, <a href="scf/chemistry_mod_f.html#input_interaction">input_interaction</a>, &
                             <a href="scf/chemistry_mod_f.html#output_monomers">output_monomers</a>, <a href="scf/chemistry_mod_f.html#output_chains">output_chains</a>, <a href="scf/chemistry_mod_f.html#output_solvents">output_solvents</a>,&
                             <a href="scf/chemistry_mod_f.html#output_composition">output_composition</a>, <a href="scf/chemistry_mod_f.html#output_interaction">output_interaction</a>, &
                             <a href="scf/chemistry_mod_f.html#N_monomer">N_monomer</a>, <a href="scf/chemistry_mod_f.html#N_chain">N_chain</a>, <a href="scf/chemistry_mod_f.html#N_block">N_block</a>, <a href="scf/chemistry_mod_f.html#N_solvent">N_solvent</a>, <a href="scf/chemistry_mod_f.html#chi">chi</a>
   use <a href="crystal/unit_cell_mod_f.html#unit_cell_mod">unit_cell_mod</a>, only : <a href="crystal/unit_cell_mod_f.html#input_unit_cell">input_unit_cell</a>, <a href="crystal/unit_cell_mod_f.html#output_unit_cell">output_unit_cell</a>, &
                             <a href="crystal/unit_cell_mod_f.html#N_cell_param">N_cell_param</a>, <a href="crystal/unit_cell_mod_f.html#cell_param">cell_param</a>, &
                             <a href="crystal/unit_cell_mod_f.html#make_unit_cell">make_unit_cell</a>, <a href="crystal/unit_cell_mod_f.html#R_basis">R_basis</a>, <a href="crystal/unit_cell_mod_f.html#G_basis">G_basis</a>
   use <a href="crystal/group_mod_f.html#group_mod">group_mod</a>,     only : <a href="crystal/group_mod_f.html#output_group">output_group</a>
   use <a href="grid/grid_mod_f.html#grid_mod">grid_mod</a>,      only : <a href="grid/grid_mod_f.html#ngrid">ngrid</a>, <a href="grid/grid_mod_f.html#input_grid">input_grid</a>, <a href="grid/grid_mod_f.html#allocate_grid">allocate_grid</a>, <a href="grid/grid_mod_f.html#make_ksq">make_ksq</a>
   use <a href="crystal/basis_mod_f.html#basis_mod">basis_mod</a>,     only : <a href="crystal/basis_mod_f.html#N_wave">N_wave</a>, <a href="crystal/basis_mod_f.html#N_star">N_star</a>, group, &
                             <a href="crystal/basis_mod_f.html#make_basis">make_basis</a>, <a href="crystal/basis_mod_f.html#output_waves">output_waves</a>, <a href="crystal/basis_mod_f.html#release_basis">release_basis</a>
   
   use <a href="grid/fft3_mod_f.html#fft_mod">fft_mod</a>,        only : <a href="grid/fft3_mod_f.html#fft_plan">fft_plan</a>, <a href="grid/fft3_mod_f.html#create_fft_plan">create_fft_plan</a>, <a href="grid/fft3_mod_f.html#fft">fft</a>, <a href="grid/fft3_mod_f.html#ifft">ifft</a>

   use <a href="crystal/grid_basis_mod_f.html#grid_basis_mod">grid_basis_mod</a>
   use <a href="scf/chain_mod_f.html#chain_mod">chain_mod</a>
   use <a href="scf/scf_mod_f.html#scf_mod">scf_mod</a>,       only : <a href="scf/scf_mod_f.html#density_startup">density_startup</a>, <a href="scf/scf_mod_f.html#density">density</a>
   use <a href="iterate/iterate_mod_f.html#iterate_mod">iterate_mod</a>,   only : <a href="iterate/iterate_mod_f.html#input_iterate_param">input_iterate_param</a>, <a href="iterate/iterate_mod_f.html#output_iterate_param">output_iterate_param</a>, itr_algo, &
                             <a href="iterate/iterate_mod_f.html#iterate_NR_startup">iterate_NR_startup</a>, <a href="iterate/iterate_mod_f.html#iterate_AM_startup">iterate_AM_startup</a>, <a href="iterate/iterate_mod_f.html#iterate_NR">iterate_NR</a>, iterate_AM, <a href="iterate/iterate_mod_f.html#domain">domain</a>
   use <a href="iterate/sweep_mod_f.html#sweep_mod">sweep_mod</a> 
   use <a href="response/response_mod_f.html#response_mod">response_mod</a>,  only : <a href="response/response_mod_f.html#response_startup">response_startup</a>, <a href="response/response_mod_f.html#response_sweep">response_sweep</a>
   implicit none

   ! FFT variable
   type(<a href="grid/fft3_mod_f.html#fft_plan">fft_plan</a>)  :: <a href="scf/scf_mod_f.html#plan">plan</a>

   ! SCFT variables
   real(<a href="const_mod_f.html#long">long</a>)      :: omega(:,:)      ! chemical potential field 
                                      ! omega(monomer,basis function)
   real(<a href="const_mod_f.html#long">long</a>)      :: rho(:,:)        ! monomer <a href="scf/scf_mod_f.html#density">density</a> field
                                      ! rho(monomer,basis function)
   real(<a href="const_mod_f.html#long">long</a>)      :: f_Helmholtz     ! free energy, units kT / monomer 
   real(<a href="const_mod_f.html#long">long</a>)      :: pressure        ! pressure * V_monomer / kT 
   real(<a href="const_mod_f.html#long">long</a>)      :: stress(:)       ! d(f_Helmholtz)/d(<a href="crystal/unit_cell_mod_f.html#cell_param">cell_param</a>)
   allocatable     :: omega, rho, stress

   ! Input parameters (all others declared in modules)
   character(60)   :: group_name      ! name of crystal space group
   real(<a href="const_mod_f.html#long">long</a>)      :: chain_step      ! contour length step size
   real(<a href="const_mod_f.html#long">long</a>)      :: vref_scale      ! Factor to rescale reference volume

   ! Input and <a href="io/io_mod_f.html#output">output</a> file names
   character(60)   :: input_prefix    ! prefix for <a href="io/io_mod_f.html#input">input</a> omega file:
                                      !   input_prefix//omega
   character(60)   :: output_prefix   ! prefix for <a href="io/io_mod_f.html#output">output</a> files:
                                      !   output_prefix//out
                                      !   output_prefix//omega
                                      !   output_prefix//rho
                                      !   output_prefix//group
                                      !   output_prefix//waves
   character(60)   :: input_file      ! <a href="io/io_mod_f.html#input">input</a> file for FIELD_TO_GRID
   character(60)   :: output_file     ! <a href="io/io_mod_f.html#output">output</a> file for FIELD_TO_GRID

   !  Variable for Kgrid to Rgrid transformation
   integer                     :: i1, i2, i3, alpha
   complex(<a href="const_mod_f.html#long">long</a>), allocatable  :: k_grid(:,:,:,:)
   real(<a href="const_mod_f.html#long">long</a>), allocatable     :: r_grid(:,:,:,:)
   real(<a href="const_mod_f.html#long">long</a>), allocatable     :: omega_basis(:,:)
   real                        :: ff, qR
   real(<a href="const_mod_f.html#long">long</a>)                  :: rnodes       ! number of grid points
   character(25)               :: fmt

   ! Variables for iteration (fixed chemistry)
   integer         :: extr_order      ! extrapolation order
   integer         :: itr             ! iteration index
   real(<a href="const_mod_f.html#long">long</a>)      :: error           ! error = max(residual)
   logical         :: converge        ! true if converged
   character(10)   :: algo

   ! Variables for sweep (sequence of parameters)
   integer         :: i, j            ! step indices
   real(<a href="const_mod_f.html#long">long</a>)      :: s_max           ! maximum value of variable s
   real(<a href="const_mod_f.html#long">long</a>)      :: s               ! <a href="iterate/sweep_mod_f.html#continuation">continuation</a> variable
   real(<a href="const_mod_f.html#long">long</a>)      :: step            ! actual step size
   real(<a href="const_mod_f.html#long">long</a>)      :: step_unit       ! unit step size 

   ! Operation selection string from <a href="io/io_mod_f.html#input">input</a> script
   character(60)   :: op_string      ! Operation selection string

   ! Logical operation flags - set true as each operation requested
   ! Note: These are listed in normal sequence within <a href="io/io_mod_f.html#input">input</a> file
   logical :: monomer_flag           = .FALSE. ! monomer data read
   logical :: chain_flag             = .FALSE. ! chain data read
   logical :: solvent_flag           = .FALSE. ! solvent data read
   logical :: composition_flag       = .FALSE. ! composition data read
   logical :: interaction_flag       = .FALSE. ! interaction data read
   logical :: unit_cell_flag         = .FALSE. ! unit_cell made
   logical :: discretize_flag        = .FALSE. ! grid and ds made
   logical :: prefix_flag            = .FALSE. ! io file prefixes read
   logical :: basis_flag             = .FALSE. ! symmetrized basis made
   logical :: omega_flag             = .FALSE. ! initial omega exists
   logical :: iterate_flag           = .FALSE. ! 1st iteration requested
   logical :: output_flag            = .FALSE. ! deferred iterate <a href="io/io_mod_f.html#output">output</a>
   logical :: sweep_flag             = .FALSE. ! sweep requested
   logical :: rho_flag               = .FALSE. ! initial_rho_exist

   ! Timing variables
   real(<a href="const_mod_f.html#long">long</a>) :: start_time, basis_time, scf_time
   real(<a href="const_mod_f.html#long">long</a>) :: rpa_time

   ! File Unit numbers (parameters)
   integer, parameter :: out_unit   = 21 ! <a href="io/io_mod_f.html#output">output</a> summary
   integer, parameter :: field_unit = 22 ! omega and rho fields
   integer            :: ierr            ! error msg for file io

   ! File format version numbers
   type(<a href="io/version_mod_f.html#version_type">version_type</a>) :: version      ! <a href="io/io_mod_f.html#input">input</a> script format
   !------------------------------------------------------------------

   call cpu_time(start_time)

   ! Set defaults for parameter I/O - see <a href="io/io_mod_f.html#io_mod">io_mod</a>
   call <a href="io/io_mod_f.html#set_echo">set_echo</a>(1)                ! echo inputs to standard out
   call <a href="io/io_mod_f.html#set_com_style">set_com_style</a>('A','A','A') ! comments on line above data
   call <a href="io/io_mod_f.html#set_com_use">set_com_use</a>('R')           ! replace comment in echoed <a href="io/io_mod_f.html#output">output</a>
   call <a href="io/io_mod_f.html#set_io_units">set_io_units</a>(i=5,o=6)      ! set standard in and out units

   ! Read file format version from <a href="io/io_mod_f.html#input">input</a> script, echo to stdout
   call <a href="io/version_mod_f.html#input_version">input_version</a>(version, 5)
   call <a href="io/version_mod_f.html#output_version">output_version</a>(version, 6)

   ! Main operation loop - infinite loop
   op_loop : do 
 
      ! Read operation string from stdin 
      read(5,*)
      read(5,*) op_string
 
      ! Echo to stdout
      write(6,*)
      call <a href="io/io_mod_f.html#output">output</a>(trim(op_string),f="N",j="L",o=6)
 
      select case(trim(op_string))
 
      case ("CHEMISTRY")

         ! Input old format for chemistry, in which information about
         ! monomers, chains, solvents, composition, and interaction 
         ! are in one large block. Included temporarily for backwards 
         ! compatability. 
         monomer_flag     = .TRUE.
         chain_flag       = .TRUE.
         solvent_flag     = .TRUE.
         composition_flag = .TRUE.
         interaction_flag = .TRUE.
 
         ! Read chemistry data from stdin ( see <a href="scf/chemistry_mod_f.html#chemistry_mod">chemistry_mod</a> )
         call <a href="scf/chemistry_mod_f.html#input_chemistry">input_chemistry</a>(5,'F')  

      case ("MONOMERS")

        ! Input <a href="scf/chemistry_mod_f.html#N_monomer">N_monomer</a> and <a href="scf/chemistry_mod_f.html#kuhn">kuhn</a> array
        ! See <a href="scf/chemistry_mod_f.html#chemistry_mod">chemistry_mod</a> and users manual
 
         monomer_flag = .TRUE.
         call <a href="scf/chemistry_mod_f.html#input_monomers">input_monomers</a>(5,'F')

      case ("CHAINS")
 
        ! Input N_chains, <a href="scf/chemistry_mod_f.html#block_monomer">block_monomer</a>, <a href="scf/chemistry_mod_f.html#block_length">block_length</a>
        ! See <a href="scf/chemistry_mod_f.html#chemistry_mod">chemistry_mod</a> and users manual
 
         ! Check preconditions (must know <a href="scf/chemistry_mod_f.html#N_monomer">N_monomer</a> first)
         if (.not.monomer_flag) then
            write(6,*) "Error: Must read MONOMERS before CHAINS" 
            exit op_loop
         end if

         chain_flag  = .TRUE.
         call <a href="scf/chemistry_mod_f.html#input_chains">input_chains</a>(5,'F')

      case ("SOLVENTS")
 
        ! Input N_solvents, <a href="scf/chemistry_mod_f.html#solvent_monomer">solvent_monomer</a>, <a href="scf/chemistry_mod_f.html#solvent_size">solvent_size</a>
        ! See <a href="scf/chemistry_mod_f.html#chemistry_mod">chemistry_mod</a> and users manual
 
         ! Check preconditions (must know <a href="scf/chemistry_mod_f.html#N_monomer">N_monomer</a> first)
         if (.not.monomer_flag) then
            write(6,*) "Error: Must read MONOMERS before SOLVENTS"
            exit op_loop
         end if
         solvent_flag  = .TRUE.
         call <a href="scf/chemistry_mod_f.html#input_solvents">input_solvents</a>(5,'F')

      case ("COMPOSITION")
 
        ! Input <a href="scf/chemistry_mod_f.html#ensemble">ensemble</a>, <a href="scf/chemistry_mod_f.html#phi_chain">phi_chain</a> and <a href="scf/chemistry_mod_f.html#phi_solvent">phi_solvent</a>, or <a href="scf/chemistry_mod_f.html#mu_chain">mu_chain</a> and <a href="scf/chemistry_mod_f.html#mu_solvent">mu_solvent</a>
        ! See <a href="scf/chemistry_mod_f.html#chemistry_mod">chemistry_mod</a> and users manual

         ! Check preconditions (must know <a href="scf/chemistry_mod_f.html#N_chain">N_chain</a> and <a href="scf/chemistry_mod_f.html#N_solvent">N_solvent</a> first)
         if ( .not. (chain_flag .OR. solvent_flag) ) then
            write(6,*) &
            "Error: Must read CHAINS and/or SOLVENTS before COMPOSITION"
            exit op_loop
         end if
         composition_flag = .TRUE.

         call <a href="scf/chemistry_mod_f.html#input_composition">input_composition</a>(5,'F')

      case ("INTERACTION")

        ! Input Flory-Huggins <a href="scf/chemistry_mod_f.html#chi">chi</a> interaction parameters.
        ! Input <a href="scf/chemistry_mod_f.html#interaction_type">interaction_type</a> and:
        !    <a href="scf/chemistry_mod_f.html#chi">chi</a> (if <a href="scf/chemistry_mod_f.html#interaction_type">interaction_type</a> = '<a href="scf/chemistry_mod_f.html#chi">chi</a>'), or
        !    chi_a, chi_b, & <a href="scf/chemistry_mod_f.html#temperature">temperature</a> (if <a href="scf/chemistry_mod_f.html#interaction_type">interaction_type</a> = 'chi_T')
        ! See <a href="scf/chemistry_mod_f.html#chemistry_mod">chemistry_mod</a> and users manual

         ! Check preconditions (must know <a href="scf/chemistry_mod_f.html#N_monomer">N_monomer</a> first)
         if (.not.monomer_flag) then
            write(6,*) "Error: Must read MONOMERS before INTERACTION"
            exit op_loop
         end if
         interaction_flag = .TRUE.

         call <a href="scf/chemistry_mod_f.html#input_interaction">input_interaction</a>(5,'F')

 
      case ('UNIT_CELL')
 
         unit_cell_flag = .TRUE.
 
         ! Read unit cell parameters (see <a href="crystal/unit_cell_mod_f.html#unit_cell_mod">unit_cell_mod</a>)
         call <a href="crystal/unit_cell_mod_f.html#input_unit_cell">input_unit_cell</a>(5,'F')       
 
         ! Construct initial unit cell (see <a href="crystal/unit_cell_mod_f.html#unit_cell_mod">unit_cell_mod</a>)
         call <a href="crystal/unit_cell_mod_f.html#make_unit_cell">make_unit_cell</a> 
 
      case ('DISCRETIZATION')

         ! Read spatial and contour length discretization of PDE

         ! Check preconditions (Needs <a href="scf/chemistry_mod_f.html#N_monomer">N_monomer</a> and unit_cell parameters)
         if (.not.monomer_flag) then
            write(6,*) "Error: Must read MONOMERS before DISCRETIZATION"
            exit op_loop
         else if ( .not. unit_cell_flag ) then
            write(6,*) "Error: Must make UNIT_CELL before DISCRETIZATION"
            exit op_loop
         end if
         discretize_flag = .TRUE.

         ! Input <a href="grid/grid_mod_f.html#ngrid">ngrid</a> = number of points in FFT grid in each direction
         call <a href="grid/grid_mod_f.html#input_grid">input_grid</a>
         call <a href="grid/grid_mod_f.html#allocate_grid">allocate_grid</a>(<a href="scf/chemistry_mod_f.html#N_monomer">N_monomer</a>)
 
         !call <a href="io/io_mod_f.html#input">input</a>(extr_order,'extr_order')
         extr_order = 1
         call <a href="io/io_mod_f.html#input">input</a>(chain_step,'chain_step')
 
      case ('FILE_PREFIXES')

         ! Input prefixes used to contruct <a href="io/io_mod_f.html#input">input</a> and <a href="io/io_mod_f.html#output">output</a> file names.
         ! Prefixes can include directories paths, if they end with a
         ! trailing directory separator '/'. The <a href="io/io_mod_f.html#input">input</a> omega file name 
         ! is constructed by appending 'omega' to input_prefix. Output
         ! file names are constructed by appending 'out', 'rho' and
         ! 'omega' to output_prefix. 

         prefix_flag = .TRUE.
         call <a href="io/io_mod_f.html#input">input</a>(input_prefix, 'input_prefix')  ! <a href="io/io_mod_f.html#input">input</a>  file prefix
         call <a href="io/io_mod_f.html#input">input</a>(output_prefix,'output_prefix') ! <a href="io/io_mod_f.html#output">output</a> file prefix
 
      case ('BASIS')

         ! Construct symmetry-adapated basis functions. See <a href="crystal/basis_mod_f.html#basis_mod">basis_mod</a>

         ! Check preconditions (needs unit cell and grid)
         if ( .not. unit_cell_flag ) then
            write(6,*) "Error: Must make UNIT_CELL before BASIS"
            exit op_loop
         else if (.not.discretize_flag) then
            write(6,*) "Error: Must make DISCRETIZATION before BASIS"
            exit op_loop
         else if ( .not.prefix_flag ) then
            write(6,*) "Error: Must provide FILE_PREFIXES before BASIS"
            exit op_loop
         end if
         basis_flag = .TRUE.
 
         ! Read name of space group used to construct basis functions.
         ! The string group_name can be a space group symbol, a space 
         ! group number, or the name of a file containing the elements 
         ! of the group. See <a href="crystal/space_groups_mod_f.html#space_groups">space_groups</a> in module space_group_mod.
         call <a href="io/io_mod_f.html#input">input</a>(group_name,'group_name')
 
         ! Construct basis functions (see <a href="crystal/basis_mod_f.html#basis_mod">basis_mod</a>)
         call <a href="crystal/basis_mod_f.html#make_basis">make_basis</a>(<a href="crystal/unit_cell_mod_f.html#R_basis">R_basis</a>,<a href="crystal/unit_cell_mod_f.html#G_basis">G_basis</a>,group_name,<a href="grid/grid_mod_f.html#ngrid">ngrid</a>,grid_flag=.TRUE.)
 
         ! Output <a href="crystal/basis_mod_f.html#N_star">N_star</a> (# of symmetrized basis functions) to stdout
         call <a href="io/io_mod_f.html#output">output</a>(<a href="crystal/basis_mod_f.html#N_star">N_star</a>,'<a href="crystal/basis_mod_f.html#N_star">N_star</a>',o=6)
      
         ! Allocate omega, rho, stress (internal routine)
         call allocate_scf_arrays             
      
      case ('RESCALE')
 
         ! Rescale monomer reference volume. Change values of <a href="scf/chemistry_mod_f.html#kuhn">kuhn</a>, 
         ! <a href="scf/chemistry_mod_f.html#chi">chi</a>, <a href="scf/chemistry_mod_f.html#block_length">block_length</a>, and <a href="scf/chemistry_mod_f.html#solvent_size">solvent_size</a> parameter arrays, and
         ! the omega field, to obtain an equivalent set of parameters 
         ! and fields.
 
         ! If omega field has not been read previously, read it now
         if (.not.omega_flag) then

            ! Check preconditions for reading omega
            if (.not.basis_flag) then
               write(6,*) "Error: Must make BASIS before RESCALE"
               exit op_loop
            else if ( .not.prefix_flag ) then
               write(6,*) &
                  "Error: Must provide FILE_PREFIXES before RESCALE"
               exit op_loop
            end if

            ! Read omega
            open(unit=field_unit,file=trim(input_prefix)//'omega',&
                              status='old',iostat=ierr)
            if (ierr/=0) stop "Error while opening omega file"
            call <a href="io/field_io_mod_f.html#input_field">input_field</a>(omega,field_unit)
            close(field_unit)
            omega_flag = .TRUE.

         end if
 
         ! Read in scale factor: vref -> vref/vref_scale
         call <a href="io/io_mod_f.html#input">input</a>(vref_scale,'vref_scale')

         ! Rescale <a href="scf/chemistry_mod_f.html#kuhn">kuhn</a>, <a href="scf/chemistry_mod_f.html#chi">chi</a>, <a href="scf/chemistry_mod_f.html#block_length">block_length</a>, <a href="scf/chemistry_mod_f.html#solvent_size">solvent_size</a> 
         ! See <a href="scf/chemistry_mod_f.html#chemistry_mod">chemistry_mod</a>
         call <a href="scf/chemistry_mod_f.html#rescale_vref">rescale_vref</a>(vref_scale)

         ! Rescale omega field
         omega = omega/vref_scale
 
      case ('ITERATE')

         ! Iterate to convergence for one set of parameters
         ! See <a href="iterate/iterate_mod_f.html#iterate_mod">iterate_mod</a>
         ! Check preconditions
         if (.not.composition_flag) then
            write(6,*) "Error: Must read COMPOSITION before ITERATION"
            exit op_loop
         else if (.not.interaction_flag) then
            write(6,*) "Error: Must read INTERACTION before ITERATION"
            exit op_loop
         else if (.not.unit_cell_flag) then
            write(6,*) "Error: Must make UNIT_CELL before ITERATION"
            exit op_loop
         else if (.not.discretize_flag) then
            write(6,*) "Error: Must make DISCRETIZATION before ITERATION"
            exit op_loop
         else if (.not.basis_flag) then
            write(6,*) "Error: Must make BASIS before ITERATION"
            exit op_loop
         else if ( .not.prefix_flag ) then
            write(6,*) "Error: Must read FILE_PREFIXES before ITERATION"
            exit op_loop
         end if

         ! Read omega file, if not read previously
         if (.not.omega_flag) then
            open(unit=field_unit,file=trim(input_prefix)//'omega',&
                              status='old',iostat=ierr)
            if (ierr/=0) stop "Error while opening omega source file."
            call <a href="io/field_io_mod_f.html#input_field">input_field</a>(omega,field_unit)
            close(field_unit)
            omega_flag = .TRUE.
         end if
        
         iterate_flag = .TRUE.
 
         call cpu_time(basis_time)
         basis_time = basis_time - start_time
         call cpu_time(start_time)
 
         ! Read parameters for iteration
         call <a href="iterate/iterate_mod_f.html#input_iterate_param">input_iterate_param</a>
 
         ! Allocate and initialize chain objects used in <a href="scf/scf_mod_f.html#scf_mod">scf_mod</a>
         ! Create <a href="grid/fft3_mod_f.html#fft_plan">fft_plan</a>, which is saved in <a href="scf/scf_mod_f.html#scf_mod">scf_mod</a> as public variable
         call <a href="scf/scf_mod_f.html#density_startup">density_startup</a>(<a href="grid/grid_mod_f.html#ngrid">ngrid</a>,extr_order,chain_step,&
                                  update_chain=.false.)

         if(itr_algo=='NR')then

             ! Allocate private arrays for Newton-Raphson iteration
             call <a href="iterate/iterate_mod_f.html#iterate_NR_startup">iterate_NR_startup</a>(<a href="crystal/basis_mod_f.html#N_star">N_star</a>)
    
             write(6,FMT = "( / '************************************' / )" )
             ! Main Newton-Raphson iteration loop
             call <a href="iterate/iterate_mod_f.html#iterate_NR">iterate_NR</a>(      &
                      <a href="crystal/basis_mod_f.html#N_star">N_star</a>,      &! # of basis functions
                      omega,       &! chemical potential field (IN/OUT)
                      itr,         &! actual number of interations
                      converge,    &! = .TRUE. if converged
                      error,       &! final error = max(residuals)
                      rho,         &! monomer <a href="scf/scf_mod_f.html#density">density</a> field
                      f_Helmholtz, &! Helmholtz free energy per monomer/kT
                      pressure,    &! pressure * monomer volume / kT
                      stress       &! d(free energy)/d(cell parameters)
                           )

         elseif(itr_algo=='AM')then

             ! Allocate private arrays for Anderson-Mixing iteration
             call <a href="iterate/iterate_mod_f.html#iterate_AM_startup">iterate_AM_startup</a>(<a href="crystal/basis_mod_f.html#N_star">N_star</a>)
    
             call iterate_AM(      &
                      <a href="crystal/basis_mod_f.html#N_star">N_star</a>,      &! # of basis functions
                      omega,       &! chemical potential field (IN/OUT)
                      itr,         &! actual number of interations
                      converge,    &! = .TRUE. if converged
                      error,       &! final error = max(residuals)
                      rho,         &! monomer <a href="scf/scf_mod_f.html#density">density</a> field
                      f_Helmholtz, &! Helmholtz free energy per monomer/kT
                      pressure,    &! pressure * monomer volume / kT
                      stress       &! d(free energy)/d(cell parameters)
                           )

         endif        

         ! Defer <a href="io/io_mod_f.html#output">output</a> to SWEEP, RESPONSE, or FINISH operation
         ! If <a href="io/io_mod_f.html#output">output</a> by SWEEP, '0.' will be added to output_prefix
         output_flag = .TRUE.
      
         call cpu_time(scf_time)
         scf_time = scf_time - start_time
 
      case ('SWEEP')

         ! Iterate to convergences for a sequence of sets of parameters.
         ! See sweep_mod.
 
         ! Must be preceded by successful ITERATE for first solution.
         if (.not.iterate_flag) then
                 write(6,*) &
                  "Error: Must call ITERATE (1st iteration) before SWEEP"
            exit op_loop
         else if (.not.converge) then
            write(6,*) "Error: 1st iteration failed to converge"
            exit op_loop
         end if
         sweep_flag = .TRUE.
 
         ! Read parameters needed by sweep
         call <a href="io/io_mod_f.html#input">input</a>(s_max,'s_max')           ! max(contour variable s)  
         call <a href="iterate/sweep_mod_f.html#input_increments">input_increments</a>(5,'N',<a href="iterate/iterate_mod_f.html#domain">domain</a>) ! see <a href="iterate/sweep_mod_f.html#sweep_mod">sweep_mod</a>
        
         ! Output from first iteration, add '0.' to output_prefix
         if (output_flag) then
            call output_summary(trim(output_prefix)//'0.')
            call output_fields(trim(output_prefix)//'0.')
            output_flag = .FALSE.
         endif
 
         ! Initialize contour variable s = 0.0 -> s_max
         s = 0.0_long
   
         ! Initialize history arrays
         call <a href="iterate/sweep_mod_f.html#history_setup">history_setup</a>
         call <a href="iterate/sweep_mod_f.html#update_history">update_history</a>(s,omega,<a href="crystal/unit_cell_mod_f.html#cell_param">cell_param</a>,<a href="iterate/iterate_mod_f.html#domain">domain</a>)
   
         ! Loop over sweep through parameters
         i         = 0
         step_unit = 1.0_long
         sweep_loop : do 
    
            if (i == 0) then
               step = 0.1*step_unit
            else if (i == 1) then
               if (converge) then
                  step = 0.9*step_unit
               else 
                  step = step_unit - s 
               end if
            else if (i > 1) then
               step = step_unit
            end if
   
            s = s + step
            call <a href="iterate/sweep_mod_f.html#increment_parameters">increment_parameters</a>(step,<a href="iterate/iterate_mod_f.html#domain">domain</a>,<a href="crystal/unit_cell_mod_f.html#cell_param">cell_param</a>)
   
            write(6, FMT = "('************************************'/ )" )
            write(6, FMT = "('s =',f10.4)" ) s
            call cpu_time(start_time)
         
            ! 1st order <a href="iterate/sweep_mod_f.html#continuation">continuation</a> of omega and <a href="crystal/unit_cell_mod_f.html#cell_param">cell_param</a>
            call <a href="iterate/sweep_mod_f.html#continuation">continuation</a>(step,<a href="iterate/iterate_mod_f.html#domain">domain</a>,omega,<a href="crystal/unit_cell_mod_f.html#cell_param">cell_param</a>)
   
            ! Reconstruct unit cell
            ! if (<a href="iterate/iterate_mod_f.html#domain">domain</a>) then
               call <a href="crystal/unit_cell_mod_f.html#make_unit_cell">make_unit_cell</a> 
               call <a href="grid/grid_mod_f.html#make_ksq">make_ksq</a>(<a href="crystal/unit_cell_mod_f.html#G_basis">G_basis</a>)
            ! end if
 
            ! Rebuild chains
            call <a href="scf/scf_mod_f.html#density_startup">density_startup</a>(<a href="grid/grid_mod_f.html#ngrid">ngrid</a>,extr_order,chain_step,&
                                 update_chain=.TRUE.)
 
            ! Main iteration routine
            if(itr_algo=='NR')then

               call <a href="iterate/iterate_mod_f.html#iterate_NR">iterate_NR</a>( &
                   <a href="crystal/basis_mod_f.html#N_star">N_star</a>,      &! # of basis functions
                   omega,       &! chemical potential field (IN/OUT)
                   itr,         &! actual number of interations
                   converge,    &! = .TRUE. if converged
                   error,       &! final error = max(residuals)
                   rho,         &! monomer <a href="scf/scf_mod_f.html#density">density</a> field
                   f_Helmholtz, &! Helmholtz free energy per monomer/kT
                   pressure,    &! pressure * monomer volume/kT
                   stress       &! d(free energy)/d(cell parameters)
                   )
               
           elseif(itr_algo=='AM')then
    
             call iterate_AM(      &
                      <a href="crystal/basis_mod_f.html#N_star">N_star</a>,      &! # of basis functions
                      omega,       &! chemical potential field (IN/OUT)
                      itr,         &! actual number of interations
                      converge,    &! = .TRUE. if converged
                      error,       &! final error = max(residuals)
                      rho,         &! monomer <a href="scf/scf_mod_f.html#density">density</a> field
                      f_Helmholtz, &! Helmholtz free energy per monomer/kT
                      pressure,    &! pressure * monomer volume / kT
                      stress       &! d(free energy)/d(cell parameters)
                           )
           endif

            if (converge) then
   
               i = i + 1
               call <a href="iterate/sweep_mod_f.html#update_history">update_history</a>(s,omega,<a href="crystal/unit_cell_mod_f.html#cell_param">cell_param</a>,<a href="iterate/iterate_mod_f.html#domain">domain</a>)
   
               call cpu_time(scf_time)
               scf_time = scf_time - start_time
  
               ! Output out, rho, and omega files if s is an integer 
               if ( abs(s-float(nint(s))) < 0.001_long ) then
                  j = nint(s)
                  ! Appending 'j.' to output_prefix in file names
                  call output_summary( &
                      trim(output_prefix)//trim(<a href="io/string_mod_f.html#int_string">int_string</a>(j))//'.' )
                  call output_fields( &
                      trim(output_prefix)//trim(<a href="io/string_mod_f.html#int_string">int_string</a>(j))//'.' )
               end if
               write(6,*)
   
            else if (step_unit > ( (1.0/16.0) + 0.001 ) ) then
   
               ! Backtrack to previous chemistry
               s = s - step
               call <a href="iterate/sweep_mod_f.html#increment_parameters">increment_parameters</a>(-step,<a href="iterate/iterate_mod_f.html#domain">domain</a>,<a href="crystal/unit_cell_mod_f.html#cell_param">cell_param</a>)
    
               ! Halve step size
               step_unit = 0.5*step_unit
    
               write(6, FMT="( / 'Backtrack and halve step_unit' / )" )
               cycle
     
            else ! If not.converge and step_unit <= 1/16, stop.
     
               write(6,*)
               write(6,*) 'Failed to converge - stop program'
               stop
   
            end if
   
            if ( (s + 0.001) >= s_max ) exit sweep_loop
   
         end do sweep_loop 
         ! end loop over sweep through parameters
 

      case ('RESPONSE')

         ! Calculate and diagonalize linear SCF response functions for
         ! a periodic microstructure. See response_mod.

         ! Check preconditions (Must iterate to convergence first)
         if (.not. iterate_flag) then
            write(6,*) "Error: Must ITERATE before calculating RESPONSE"
            exit op_loop
         end if

         ! Deferred <a href="io/io_mod_f.html#output">output</a> from ITERATE, if necessary
         if (output_flag) then
            call output_summary(output_prefix)
            call output_fields(output_prefix)
            output_flag = .FALSE.
         endif

         call <a href="response/response_mod_f.html#response_startup">response_startup</a>(Ngrid, chain_step, order=1)
         call <a href="response/response_mod_f.html#response_sweep">response_sweep</a>(Ngrid, output_prefix)
 
         call <a href="crystal/basis_mod_f.html#release_basis">release_basis</a>()
         call <a href="crystal/basis_mod_f.html#make_basis">make_basis</a>(<a href="crystal/unit_cell_mod_f.html#R_basis">R_basis</a>,<a href="crystal/unit_cell_mod_f.html#G_basis">G_basis</a>,group_name,Ngrid,grid_flag=.TRUE.)

      case ('OUTPUT_GROUP')

         ! Check preconditions (Needs group created in BASIS block)
         if (.not. basis_flag) then
            write(6,*) "Error: Must make BASIS before OUTPUT GROUP"
            exit op_loop
         end if
         open(unit=field_unit, &
              file=trim(output_prefix)//'group',status='replace')
         call <a href="crystal/group_mod_f.html#output_group">output_group</a>(group,field_unit)
         close(field_unit)

      case ('OUTPUT_WAVES')

         ! Check preconditions (Needs BASIS)
         if (.not. basis_flag) then
            write(6,*) "Error: Must make BASIS before OUTPUT WAVES"
            exit op_loop
         end if

         open(unit=field_unit,file=trim(output_prefix)//'waves',&
              status='replace')
         call <a href="crystal/basis_mod_f.html#output_waves">output_waves</a>(field_unit, group_name)
         close(field_unit)

      case ('FIELD_TO_RGRID')

         ! Read representation of field as list of coefficients of
         ! symmetrized basis functions, <a href="io/io_mod_f.html#output">output</a> file containing field
         ! values at grid points (rgrid).

         ! Check preconditions for FIELD_TO_RGRID
         if ( .not. unit_cell_flag ) then
            write(6,*) "Error: Must make UNIT_CELL before FIELD_TO_GRID"
            exit op_loop
         else if (.not.discretize_flag) then
            write(6,*) &
                  "Error: Must make DISCRETIZATION before FIELD_TO_GRID"
            exit op_loop
         else if (.not.basis_flag) then
            write(6,*) "Error: Must make BASIS before FIELD_TO_GRID"
            exit op_loop
         end if
 
         ! Deferred <a href="io/io_mod_f.html#output">output</a> from ITERATE, if necessary
         if (output_flag) then
            call output_summary(output_prefix)
            call output_fields(output_prefix)
            output_flag = .FALSE.
         endif

         ! Read <a href="io/io_mod_f.html#input">input</a> and <a href="io/io_mod_f.html#output">output</a> file names from <a href="io/io_mod_f.html#input">input</a> script
         call <a href="io/io_mod_f.html#input">input</a>(input_file,'input_filename')
         call <a href="io/io_mod_f.html#input">input</a>(output_file,'output_filename')
        
         ! Read field (coefficients of basis functions) from input_file
         open(unit=field_unit,file=trim(input_prefix)//trim(input_file),status='old')
         call <a href="io/field_io_mod_f.html#input_field">input_field</a>(rho,field_unit)
         close(field_unit)
 
         ! Write values of field on a grid to output_file 
         open(unit=field_unit,file=trim(output_prefix)//trim(output_file)//'_grid',status='replace')
         call <a href="io/field_io_mod_f.html#output_field_grid">output_field_grid</a>(rho,field_unit,<a href="grid/grid_mod_f.html#ngrid">ngrid</a>)
         close(field_unit)


      case ('KGRID_TO_RGRID')

         ! Read representation of field as list of coefficients of
         ! on FFT grid (kgrid) and <a href="io/io_mod_f.html#output">output</a> file containing field
         ! values at grid points (rgrid).

         ! Check preconditions for KGRID_TO_RGRID
         if ( .not. unit_cell_flag ) then
            write(6,*) "Error: Must make UNIT_CELL before FIELD_TO_GRID"
            exit op_loop
         else if (.not.discretize_flag) then
            write(6,*) &
                  "Error: Must make DISCRETIZATION before FIELD_TO_GRID"
            exit op_loop
         else if (.not.basis_flag) then
            write(6,*) "Error: Must make BASIS before FIELD_TO_GRID"
            exit op_loop
         end if
 

         ! Read <a href="io/io_mod_f.html#input">input</a> and <a href="io/io_mod_f.html#output">output</a> file names from <a href="io/io_mod_f.html#input">input</a> script
         call <a href="io/io_mod_f.html#input">input</a>(input_file,'input_filename')
         call <a href="io/io_mod_f.html#input">input</a>(output_file,'output_filename')
       
         allocate( k_grid(0:<a href="grid/grid_mod_f.html#ngrid">ngrid</a>(1)/2, 0:<a href="grid/grid_mod_f.html#ngrid">ngrid</a>(2)-1, 0:<a href="grid/grid_mod_f.html#ngrid">ngrid</a>(3)-1, <a href="scf/chemistry_mod_f.html#N_monomer">N_monomer</a>) )
         allocate( omega_basis(<a href="scf/chemistry_mod_f.html#N_monomer">N_monomer</a>,<a href="crystal/basis_mod_f.html#N_star">N_star</a>) )

         ! Read field (coefficients of basis functions) from input_file
         open(unit=field_unit,file=trim(input_prefix)//trim(input_file),status='old')

         ! Skip first 13 lines 
         do i=1,13
            read(field_unit,*)
         end do

         k_grid=0.0         
         do i1=0,<a href="grid/grid_mod_f.html#ngrid">ngrid</a>(1)/2
            do i2=0,<a href="grid/grid_mod_f.html#ngrid">ngrid</a>(2)-1
               do i3=0,<a href="grid/grid_mod_f.html#ngrid">ngrid</a>(3)-1
                     read(field_unit,*)k_grid(i1,i2,i3,:)
               end do 
            end do
         end do
         close(field_unit)


         call <a href="grid/fft3_mod_f.html#create_fft_plan">create_fft_plan</a>(<a href="grid/grid_mod_f.html#ngrid">ngrid</a>,<a href="scf/scf_mod_f.html#plan">plan</a>)
         do alpha=1,<a href="scf/chemistry_mod_f.html#N_monomer">N_monomer</a>
               call <a href="crystal/grid_basis_mod_f.html#kgrid_to_basis">kgrid_to_basis</a>(k_grid(:,:,:,alpha),rho(alpha,:))
         end do

         do alpha=1,<a href="scf/chemistry_mod_f.html#N_monomer">N_monomer</a>
            do i=1,<a href="crystal/basis_mod_f.html#N_star">N_star</a>
               omega_basis(alpha,i) = sum(<a href="scf/chemistry_mod_f.html#chi">chi</a>(:,alpha)*rho(:,i))
            end do
         end do


         open(unit=field_unit,file=trim(output_prefix)//trim(output_file),status='replace')
         call <a href="io/field_io_mod_f.html#output_field">output_field</a>(rho,field_unit,group_name)
         close(field_unit)

         open(unit=field_unit,file=trim(output_prefix)//trim(output_file)//'_grid',status='replace')
         call <a href="io/field_io_mod_f.html#output_field_grid">output_field_grid</a>(rho,field_unit,<a href="grid/grid_mod_f.html#ngrid">ngrid</a>)
         close(field_unit)

         open(unit=field_unit,file=trim(output_prefix)//'omega',status='replace')
         call <a href="io/field_io_mod_f.html#output_field">output_field</a>(omega_basis,field_unit,group_name)
         close(field_unit)


      case ('RGRID_TO_FIELD')

         ! Read representation of field as the values on the grid points
         ! (rgrid) , and outputs file containing field
         ! values in terms of symmetry adapted basis functions (basis).

         ! Check preconditions for RGRID_TO_FIELD
         if ( .not. unit_cell_flag ) then
            write(6,*) "Error: Must make UNIT_CELL before FIELD_TO_GRID"
            exit op_loop
         else if (.not.discretize_flag) then
            write(6,*) &
                  "Error: Must make DISCRETIZATION before FIELD_TO_GRID"
            exit op_loop
         else if (.not.basis_flag) then
            write(6,*) "Error: Must make BASIS before FIELD_TO_GRID"
            exit op_loop
         end if
 
         ! Read <a href="io/io_mod_f.html#input">input</a> and <a href="io/io_mod_f.html#output">output</a> file names from <a href="io/io_mod_f.html#input">input</a> script
         call <a href="io/io_mod_f.html#input">input</a>(input_file,'input_filename')
         call <a href="io/io_mod_f.html#input">input</a>(output_file,'output_filename')
       
         allocate( r_grid(0:<a href="grid/grid_mod_f.html#ngrid">ngrid</a>(1)-1, 0:<a href="grid/grid_mod_f.html#ngrid">ngrid</a>(2)-1, 0:<a href="grid/grid_mod_f.html#ngrid">ngrid</a>(3)-1, <a href="scf/chemistry_mod_f.html#N_monomer">N_monomer</a>) )
         allocate( k_grid(0:<a href="grid/grid_mod_f.html#ngrid">ngrid</a>(1)/2, 0:<a href="grid/grid_mod_f.html#ngrid">ngrid</a>(2)-1, 0:<a href="grid/grid_mod_f.html#ngrid">ngrid</a>(3)-1, <a href="scf/chemistry_mod_f.html#N_monomer">N_monomer</a>) )
         allocate( omega_basis(<a href="scf/chemistry_mod_f.html#N_monomer">N_monomer</a>,<a href="crystal/basis_mod_f.html#N_star">N_star</a>) )

         ! Read field values at grid points from input_file
         open(unit=field_unit,file=trim(input_prefix)//trim(input_file),status='old')
         ! Skip first 13 lines 
         do i=1,13
            read(field_unit,*)
         end do
         r_grid=0.0
         do i3=0,<a href="grid/grid_mod_f.html#ngrid">ngrid</a>(3)-1
            do i2=0,<a href="grid/grid_mod_f.html#ngrid">ngrid</a>(2)-1
               do i1=0,<a href="grid/grid_mod_f.html#ngrid">ngrid</a>(1)-1
                   read(field_unit,*)r_grid(i1,i2,i3,:)
               end do 
            end do
         end do
         close(field_unit)

         call <a href="grid/fft3_mod_f.html#create_fft_plan">create_fft_plan</a>(<a href="grid/grid_mod_f.html#ngrid">ngrid</a>,<a href="scf/scf_mod_f.html#plan">plan</a>)
         rnodes=dble( <a href="scf/scf_mod_f.html#plan">plan</a>%n(1) * <a href="scf/scf_mod_f.html#plan">plan</a>%n(2) * <a href="scf/scf_mod_f.html#plan">plan</a>%n(3) )
       
         do alpha=1,<a href="scf/chemistry_mod_f.html#N_monomer">N_monomer</a>
               call <a href="grid/fft3_mod_f.html#fft">fft</a>(<a href="scf/scf_mod_f.html#plan">plan</a>,r_grid(:,:,:,alpha),k_grid(:,:,:,alpha))
               k_grid(:,:,:,alpha)=k_grid(:,:,:,alpha)/rnodes
               call <a href="crystal/grid_basis_mod_f.html#kgrid_to_basis">kgrid_to_basis</a>(k_grid(:,:,:,alpha),rho(alpha,:))
         end do
        
         do alpha=1,<a href="scf/chemistry_mod_f.html#N_monomer">N_monomer</a>
            do i=1,<a href="crystal/basis_mod_f.html#N_star">N_star</a>
               omega_basis(alpha,i) = sum(<a href="scf/chemistry_mod_f.html#chi">chi</a>(:,alpha)*rho(:,i))
            end do
         end do

         open(unit=field_unit,file=trim(output_prefix)//trim(output_file),status='replace')
         call <a href="io/field_io_mod_f.html#output_field">output_field</a>(rho,field_unit,group_name)
         close(field_unit)
        
         open(unit=field_unit,file=trim(output_prefix)//'omega',status='replace')
         call <a href="io/field_io_mod_f.html#output_field">output_field</a>(omega_basis,field_unit,group_name)
         close(field_unit)


      case ('FINISH')

         ! Deferred <a href="io/io_mod_f.html#output">output</a> of ITERATE, if necessary
         if (output_flag) then
            call output_summary(output_prefix)
            call output_fields(output_prefix)
            output_flag = .FALSE.
         endif

         ! Stop execution
         exit op_loop
 
      case default
    
         write(6,*) 'Error: Invalid op_string'
         exit op_loop
         
      end select

   end do op_loop


contains ! internal subroutines of program <strong>pscf_pd</strong>


   subroutine allocate_scf_arrays
   !-----------------------------------------------------------------
   ! Allocate arrays omega, rho, stress
   !-----------------------------------------------------------------
   integer                 :: i        ! error for file opening
   allocate(omega(<a href="scf/chemistry_mod_f.html#N_monomer">N_monomer</a>,<a href="crystal/basis_mod_f.html#N_star">N_star</a>), stat = i)
   if (i.ne.0 ) stop 'Error allocating omega'
   allocate(rho(<a href="scf/chemistry_mod_f.html#N_monomer">N_monomer</a>,<a href="crystal/basis_mod_f.html#N_star">N_star</a>), stat = i)
   if (i.ne.0) stop 'Error allocating rho'
   allocate(stress(<a href="crystal/unit_cell_mod_f.html#N_cell_param">N_cell_param</a>), stat = i )
   if (i.ne.0) stop 'Error allocating stress'
   end subroutine allocate_scf_arrays
   !=================================================================


   subroutine output_summary(prefix)
   !-----------------------------------------------------------------
   ! Writes the <a href="io/io_mod_f.html#output">output</a> summary to the file output_prefix//suffix
   !-----------------------------------------------------------------
   use <a href="scf/chemistry_mod_f.html#chemistry_mod">chemistry_mod</a>, only : <a href="scf/chemistry_mod_f.html#output_chemistry">output_chemistry</a>, <a href="scf/chemistry_mod_f.html#N_chain">N_chain</a>, <a href="scf/chemistry_mod_f.html#N_solvent">N_solvent</a>, &
                             <a href="scf/chemistry_mod_f.html#ensemble">ensemble</a>,<a href="scf/chemistry_mod_f.html#phi_chain">phi_chain</a>,<a href="scf/chemistry_mod_f.html#phi_solvent">phi_solvent</a>,<a href="scf/chemistry_mod_f.html#mu_chain">mu_chain</a>, &
                             <a href="scf/chemistry_mod_f.html#mu_solvent">mu_solvent</a>, <a href="scf/chemistry_mod_f.html#interaction_type">interaction_type</a>, <a href="scf/chemistry_mod_f.html#chi">chi</a>
   use <a href="scf/scf_mod_f.html#scf_mod">scf_mod</a>, only       : <a href="scf/scf_mod_f.html#free_energy_FH">free_energy_FH</a>
   character(*) :: prefix

   real(<a href="const_mod_f.html#long">long</a>)   :: f_homo  ! FH free energy, kT / monomer

   open(file=trim(prefix)//'out',unit=out_unit,status='replace')
   call <a href="io/io_mod_f.html#set_io_units">set_io_units</a>(o=out_unit)

   ! Set version number for *.out file
   version%major = 1
   version%minor = 0
   call <a href="io/version_mod_f.html#output_version">output_version</a>(version, out_unit)

   ! Output in format of <a href="io/io_mod_f.html#input">input</a> driver file 
   if (monomer_flag) then
      write(out_unit,*)
      call <a href="io/io_mod_f.html#output">output</a>('MONOMERS',f='N',j='L')
      call <a href="scf/chemistry_mod_f.html#output_monomers">output_monomers</a>(out_unit,'F')
   end if
   if (chain_flag) then
      write(out_unit,*)
      call <a href="io/io_mod_f.html#output">output</a>('CHAINS',f='N',j='L')
      call <a href="scf/chemistry_mod_f.html#output_chains">output_chains</a>(out_unit,'F')
   end if
   if (solvent_flag) then
      write(out_unit,*)
      call <a href="io/io_mod_f.html#output">output</a>('SOLVENTS',f='N',j='L')
      call <a href="scf/chemistry_mod_f.html#output_solvents">output_solvents</a>(out_unit,'F')
   end if
   if (composition_flag) then
      write(out_unit,*)
      call <a href="io/io_mod_f.html#output">output</a>('COMPOSITION',f='N',j='L')
      call <a href="scf/chemistry_mod_f.html#output_composition">output_composition</a>(out_unit,'F')
   end if
   if (interaction_flag) then
      write(out_unit,*)
      call <a href="io/io_mod_f.html#output">output</a>('INTERACTION',f='N',j='L')
      call <a href="scf/chemistry_mod_f.html#output_interaction">output_interaction</a>(out_unit,'F')
   end if
   if (unit_cell_flag) then
      write(out_unit,*)
      call <a href="io/io_mod_f.html#output">output</a>('UNIT_CELL',f='N',j='L')
      call <a href="crystal/unit_cell_mod_f.html#output_unit_cell">output_unit_cell</a>(out_unit,'F')
   end if
   if (discretize_flag) then
      write(out_unit,*)
      call <a href="io/io_mod_f.html#output">output</a>('DISCRETIZATION',f='N',j='L')
      call <a href="io/io_mod_f.html#output">output</a>(<a href="grid/grid_mod_f.html#ngrid">ngrid</a>,<a href="const_mod_f.html#dim">dim</a>,'<a href="grid/grid_mod_f.html#ngrid">ngrid</a>')
      call <a href="io/io_mod_f.html#output">output</a>(chain_step,'chain_step')
      !call <a href="io/io_mod_f.html#output">output</a>(extr_order,'extr_order')
   end if
   if (prefix_flag) then
      write(out_unit,*)
      call <a href="io/io_mod_f.html#output">output</a>('FILE_PREFIXES',f='N',j='L')
      call <a href="io/io_mod_f.html#output">output</a>(trim(input_prefix), 'input_prefix')
      call <a href="io/io_mod_f.html#output">output</a>(trim(output_prefix),'output_prefix')
   end if
   if (basis_flag) then
      write(out_unit,*)
      call <a href="io/io_mod_f.html#output">output</a>('BASIS',f='N',j='L')
      call <a href="io/io_mod_f.html#output">output</a>(trim(group_name),'group_name')
   end if
   if (iterate_flag) then
      write(out_unit,*)
      call <a href="io/io_mod_f.html#output">output</a>('ITERATE',f='N',j='L')
      call <a href="iterate/iterate_mod_f.html#output_iterate_param">output_iterate_param</a>
   end if
   if (sweep_flag) then
      write(out_unit,*)
      call <a href="io/io_mod_f.html#output">output</a>('SWEEP',f='N',j='L')
      call <a href="io/io_mod_f.html#output">output</a>(s_max,'s_max')
      call <a href="iterate/sweep_mod_f.html#output_increments">output_increments</a>(out_unit,'N',<a href="iterate/iterate_mod_f.html#domain">domain</a>)
   end if
   write(out_unit,*)
   call <a href="io/io_mod_f.html#output">output</a>('FINISH',f='N',j='L')

   ! End <a href="io/io_mod_f.html#output">output</a> of <a href="io/io_mod_f.html#input">input</a> script, begin additional information

   ! Thermodynamics 
   write(out_unit,*)
   call <a href="io/io_mod_f.html#output">output</a>('THERMO',f='N',j='L')
   call <a href="io/io_mod_f.html#output">output</a>(f_Helmholtz,'f_Helmholtz')
   f_homo = <a href="scf/scf_mod_f.html#free_energy_FH">free_energy_FH</a>(<a href="scf/chemistry_mod_f.html#phi_chain">phi_chain</a>,<a href="scf/chemistry_mod_f.html#phi_solvent">phi_solvent</a>)
   call <a href="io/io_mod_f.html#output">output</a>(f_homo,     'f_homo')
   call <a href="io/io_mod_f.html#output">output</a>(pressure,   'pressure')
   select case(<a href="scf/chemistry_mod_f.html#ensemble">ensemble</a>)
   case(0) ! phi was <a href="io/io_mod_f.html#output">output</a> by <a href="io/io_mod_f.html#output">output</a> chemistry, so
      if( <a href="scf/chemistry_mod_f.html#N_chain">N_chain</a> > 0 ) then
         call <a href="io/io_mod_f.html#output">output</a>(<a href="scf/chemistry_mod_f.html#mu_chain">mu_chain</a>,<a href="scf/chemistry_mod_f.html#N_chain">N_chain</a>,'<a href="scf/chemistry_mod_f.html#mu_chain">mu_chain</a>',s='C')
      end if
      if( <a href="scf/chemistry_mod_f.html#N_solvent">N_solvent</a> > 0 ) then
         call <a href="io/io_mod_f.html#output">output</a>(<a href="scf/chemistry_mod_f.html#mu_solvent">mu_solvent</a>,<a href="scf/chemistry_mod_f.html#N_solvent">N_solvent</a>,'<a href="scf/chemistry_mod_f.html#mu_solvent">mu_solvent</a>',s='C')
      end if
   case(1) ! mu was <a href="io/io_mod_f.html#output">output</a> chemistry, so
      if( <a href="scf/chemistry_mod_f.html#N_chain">N_chain</a> > 0) then
         call <a href="io/io_mod_f.html#output">output</a>(<a href="scf/chemistry_mod_f.html#phi_chain">phi_chain</a>,<a href="scf/chemistry_mod_f.html#N_chain">N_chain</a>,'<a href="scf/chemistry_mod_f.html#phi_chain">phi_chain</a>',s='C')
      end if
      if ( <a href="scf/chemistry_mod_f.html#N_solvent">N_solvent</a> > 0) then
         call <a href="io/io_mod_f.html#output">output</a>(<a href="scf/chemistry_mod_f.html#phi_solvent">phi_solvent</a>,<a href="scf/chemistry_mod_f.html#N_solvent">N_solvent</a>,'<a href="scf/chemistry_mod_f.html#phi_solvent">phi_solvent</a>',s='C')
      end if 
   end select
   call <a href="io/io_mod_f.html#output">output</a>(stress,<a href="crystal/unit_cell_mod_f.html#N_cell_param">N_cell_param</a>,'stress')

   ! Output <a href="scf/chemistry_mod_f.html#chi">chi</a> if <a href="scf/chemistry_mod_f.html#chi">chi</a> is <a href="io/io_mod_f.html#input">input</a> as <a href="scf/chemistry_mod_f.html#chi">chi</a> = <a href="scf/chemistry_mod_f.html#chi_A">chi_A</a>/T + B
   if (<a href="scf/chemistry_mod_f.html#interaction_type">interaction_type</a> =='chi_T') then
      call <a href="io/io_mod_f.html#output">output</a>(<a href="scf/chemistry_mod_f.html#chi">chi</a>,<a href="scf/chemistry_mod_f.html#N_monomer">N_monomer</a>,<a href="scf/chemistry_mod_f.html#N_monomer">N_monomer</a>,'<a href="scf/chemistry_mod_f.html#chi">chi</a>',s='L')
   end if
 

   ! Timing and resource statistics
   write(out_unit,*)
   call <a href="io/io_mod_f.html#output">output</a>('STATISTICS',f='N',j='L')
   call <a href="io/io_mod_f.html#output">output</a>(<a href="crystal/basis_mod_f.html#N_star">N_star</a>,'<a href="crystal/basis_mod_f.html#N_star">N_star</a>')
   call <a href="io/io_mod_f.html#output">output</a>(error,'Final Error') 
   call <a href="io/io_mod_f.html#output">output</a>(itr,'Iterations') 
   call <a href="io/io_mod_f.html#output">output</a>(basis_time,'Basis Time') 
   call <a href="io/io_mod_f.html#output">output</a>(scf_time,'SCF Time') 

   close(out_unit)             ! close output_prefix//'out' file
   call <a href="io/io_mod_f.html#set_io_units">set_io_units</a>(o=6)      ! reset default echo unit to stdout

   end subroutine output_summary
   !============================================================


   subroutine output_fields(prefix)
   !-----------------------------------------------------------------
   ! Writes the <a href="io/io_mod_f.html#output">output</a> summary to the file output_prefix//suffix
   !-----------------------------------------------------------------
   character(*) :: prefix

   open(file=trim(prefix)//'omega', unit=field_unit,status='replace')
   call <a href="io/field_io_mod_f.html#output_field">output_field</a>(omega,field_unit,group_name)
   close(field_unit)
 
   open(file=trim(prefix)//'rho',unit=field_unit,status='replace')
   call <a href="io/field_io_mod_f.html#output_field">output_field</a>(rho,field_unit,group_name)
   close(field_unit)

   end subroutine output_fields
   !============================================================

end program <strong>pscf_pd</strong>
</pre>
</body>
</html>